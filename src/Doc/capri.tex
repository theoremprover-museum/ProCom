%%%****************************************************************************
%%% $Id: capri.tex,v 1.5 1995/03/20 21:24:47 gerd Exp $
%%%============================================================================
%%% 
%%% This file is part of ProCom.
%%% It is distributed under the GNU General Public License.
%%% See the file COPYING for details.
%%% 
%%% (c) Copyright 1995 Gerd Neugebauer
%%% 
%%% Net: gerd@imn.th-leipzig.de
%%% 
%%%****************************************************************************
% Master File: manual.tex

\chapter{Programming \ProCom}

%------------------------------------------------------------------------------
\input{libraries}


%------------------------------------------------------------------------------
\section{Implementing a Calculus}

To integrate a new calculus into \ProCom{} can be done dynamically or
statically. In the first case you have to write a \CaPrI{} description file
which is dynamically loaded if required. Those files are not taken into
account when an appropriate prover is selected.

Alternatiely you can integrate the new calculus into the precompiled \ProCom{}
executable. In this case it is considered as a possible prover to be used when
none is given or the given one is not appropriate.

To use a dynamic \CaPrI{} description file you have to
\begin{enumerate}
  \item Write a description file as described in the next sections.
  \item Put it on the search path such that dynamic loading can find it.
    The search path is given by the option |ProCom:capri_path|. To find the
    files the extensions from the options |ProCom:capri_extensions| are taken
    into account.
\end{enumerate}


To integrate a new calculus into the compiled \ProCom{} is done in three steps
\begin{enumerate}
  \item Write a description file as described in the next sections.
  \item Add a line in {\sf Makefile} as described in section
    \ref{sec:installation}.
  \item Recompile \ProCom{} as described in section~\ref{sec:recompile}.
\end{enumerate}



%------------------------------------------------------------------------------
\subsection{Configuring \ProCom}\label{procom.config}

The configuration can be performed at several levels. The most desirable place
is the Makefile (see section \ref{sec:installation}. Another file --- which is
automatically generated by the Makefile --- is described next.

The file {\sf ProCom/procom.cfg}\/ is a simple Prolog file which contains
facts for the Prolog predicate |define_prover/1|. Those facts describe which
modules should be loaded into the resulting \ProCom{} executable.

Several provers can be loaded at the same time. The selection for one
compilation is done with the option |prover| (see \pageref{opt:prover}).
Consider the following example of a file {\sf ProCom/procom.cfg}.

\begin{Sample}\index{define\_prover}
\begin{verbatim}
define_prover(extension_procedure).
define_prover(me_paramod).
define_prover(my_own_calculus).
\end{verbatim}
\end{Sample}

In this case three provers are defined. They can be activated with the
settings
\\ |prover = procom(extension_procedure)|,
\\ |prover = procom(me_para)|, or
\\ |prover = procom(my_own_calculus)| respectively.


The prover used is selected according to the following strategy:
\begin{itemize}
\item If the prover specified in the option |prover| is applicable then this
  prover is used. A prover is applicable if the options which are declared to
  be required are set appropriately (see page \pageref{require_option}).

\item If the specified prover is not applicable then each prover given in the
  configuration file {\sf ProCom/procom.cfg}\footnote{This file is
    created automatically by the Makefile.} is tried in turn until one is
  found which is applicable.
\end{itemize}



\subsection{The Framework}

If you want to create a new prover using the CaPrI interface you have to write
a new module. This module has to be compatible with the existing ones.
Basically three distinct pieces of information are involved in this process:
\begin{itemize}
  \item The name of the module.\\
	This name is given in the |module/1| declaration.
  \item The file name of the module.\\
	This file name is used when writing a new module.
  \item The predicate performing the compilation.\\
	This predicate is used implicitely and you don't have to care about
	it, except that you should not use such a predicate yourself.
\end{itemize}

Thus the starting point is a file named {\em my\_own\_calculus}|.pl| which
starts with the following code:
\smallskip

{\bf :- module({\em my\_own\_calculus}).\\
     :- compile(library(capri)).
}
\medskip

The first line starts a new module with the name given. The second directive
ensures that the CaPrI driver routines are included and a predicate {\em
my\_own\_calculus} is defined.

To continue you can consult the next sections to see which instructions can be
used further on.


\subsection{Describing Deduction Steps}

\begin{description}
  \item [descriptor {\em Code}.]\index{descriptor}\ \\
	{\em Code}\/ is a comma seperated list of goals of the form described
	below.
\end{description}

Consider the following example which implements the reduction step of the
extension procedure. This step says that a {\em goal}\/ |Pred| can be solved
by finding the negated literal |-Pred| on the {\em path}. Additionally we can
name this proof step as |reduction(Pred)|. This information is used to
construct a proof tree (if desired).

\begin{BoxedSample}
descriptor
        proof(reduction(Pred)),
        template(Pred,goal),
        template(-Pred,path).
\end{BoxedSample}



\begin{description}
  \item [name({\em Name})]\index{Capri!name}\ 
    \\
    This specification is meant to name a deduction step. It is optional to
    provide it. If none is given then the functor of |proof| (see below) or a
    default is used.

    It can be desirable to distinguish some deduction steps even so they
    generate the same node in the proof tree.

  \item [proof({\em Proof})]\index{Capri!proof}\ 
    \\
    This specification is used to generate the proof tree. The functor of {\em
      Proof}\/ may also be used as the name of a deduction step (see above).
    Thus {\em Proof}\/ is required to be a compound term.

  \item [template({\em Pattern})]\index{Capri!template}\ 
    \\
    This template is a short form to determine a goal pattern. All goal
    patterns leading to one instance of a deduction step are unified. Thus
    various aspects of a goal can be used.

    The following example describes any goal which has a positive sign.

    \begin{BoxedSample}
      templates(++Literal)%
    \end{BoxedSample}

  \item [template({\em Pattern}, goal)]\index{Capri!goal template}\ 
    \\
    This template is used to determine the goal literal to start with.
    Each descriptor must have at least one goal template. Otherwise no 	code
    is generated for it.

    The following example describes any goal which has a positive sign 	again,
    but this time a complete version (no abbreviation) is used.

    \begin{BoxedSample}
      templates(++Literal,goal)%
    \end{BoxedSample}

%  \item [template({\em Pattern}, goal({\em Index}))]

  \item [template({\em Pattern}, path)]\index{Capri!path template}\ 
    \\ 
    This template describes a subgoal which is solved by unifying it with a
    literal on the path.

    The following example can be understood as a part of the extension
    procedure. The negated literal |-Literal| is searched on the path.

    \begin{BoxedSample}
      templates(-Literal,path)%
    \end{BoxedSample}

  \item [template({\em Pattern}, path({\em Info}))]\index{Capri!path
      template}\ 
    \\
    This template describes a subgoal which is solved by unifying it with
    a literal on the path. The additional argument to |path| constitutes a
    way to get hold of information stored about the element on the path.
    This templete will lead to a compiletime/runtime error when the path
    library does not provide the appropriate predicates.

    \begin{BoxedSample}
      templates(-Literal,path(X))%
    \end{BoxedSample}

  \item [template({\em Pattern}, extension({\em
      LiteralIndex}))]\index{Capri!extension template}\ 
    \\
    This template describes a subgoal {\em Pattern}\/ which is solved by
    unifying it with a complementary literal somewhere in the matrix. The
    other subgoals of the clause containing the complemntary literal are left
    as residues. The argument {\em LiteralIndex}\/ is unified with the index
    of the complementary literal.

    \begin{BoxedSample}
      templates(--Literal,extension(C-L))%
    \end{BoxedSample}

  \item [template({\em Pattern}, extension)]\index{Capri!extension template}\ 
    \\
    This template acts like the pattern above, but not literal index is
    used/returned.

	
    \begin{BoxedSample}
      templates(--Literal,extension)%
    \end{BoxedSample}

  \item [template({\em Pattern}, residue)]\index{Capri!residue template}\ 
    \\
    A residue is directly translated into a call to the associated
    procedure. I.e. The goal will be solved with any means provided by the
    calculus in action.

    \begin{BoxedSample}
      templates((A=B),residue)%
    \end{BoxedSample}

  \item [template({\em Pattern}, neg\_residue)]\index{Capri!neg residue
      template}\ 
    \\
    A residue is directly translated into a call to the associated procedure
    after it has been negated. I.e. The goal will be solved with any means
    provided by the calculus in action.

    \begin{BoxedSample}
      templates((A=B),neg\_residue)%
    \end{BoxedSample}

  \item [template({\em Pattern}, {\em ListOfSelectors})]\index{Capri!list of
      templates}\ 
    \\
    This template describes a subgoal which is solved by applyig one of the
    selectors in {\em ListOfSelectors}. This list acts like a disjunction of
    possible selectors. {\em ListOfSelectors} is a list of simple selectors
    described above.

    The following example is used to write two disjoint descriptors --- which
    differ in this one template only --- in a single descriptor.

    \begin{BoxedSample}
      templates(Literal,[extension(E),path])%
    \end{BoxedSample}


  \item [template({\em PatternList}, {\em Selector})]

  \item [template({\em PatternList}, map({\em
      Selector,\ldots,Selector}))]\index{Capri!map template}\ 
    \\
    This template describes a list of patterns. Each pattern may use any of
    the selectors given in the map, but each element of the map is used
    exactly once. Thus |map| has the same number of arguments as {\em
      PatternList} has elements.

    \begin{BoxedSample}
      templates([L1,L2,L3],map([extension,path],goal,residue)%
    \end{BoxedSample}


  \item [some\_templates({\em Pattern},  
    {\em ListOfSelectors})]\index{Capri!some templates}\ 
    \\

    \begin{BoxedSample}
      some\_templates(Literal,[extension(E),path])%
    \end{BoxedSample}

  \item [some\_templates({\em Pattern},  
			 {\em ListOfSelectors},  
			 {\em Predicate})]\index{Capri!some templates}

  \item [some\_templates({\em Pattern}, 
    {\em ListOfSelectors},
    {\em Limit})]\index{Capri!some templates}\ 
    \\

    \begin{BoxedSample}
      some\_templates(Literal,[extension(E),path],23)%
    \end{BoxedSample}
    
    \begin{BoxedSample}
      some\_templates(Literal,[extension(E),path],1-7)%
    \end{BoxedSample}
    
    \begin{BoxedSample}
      some\_templates(Literal,[extension(E),path],at\_least(3))%
    \end{BoxedSample}


  \item [call({\em Prolog\_Code})]\index{Capri!call}\ 
    \\
    The given {\em Prolog\_Code}\/ is executed during the compilation.  This
    feature can be used to check certain conditions and omit the generation of
    code if those conditions do not hold by failing.  On the other side this
    instruction can be used to compute things not accessible in the current
    phase of implementation.
    
    \begin{BoxedSample}
      call(writeln('\%\%\% Checkpoint'))%
    \end{BoxedSample}

  \item [constructor({\em Prolog\_Code})]\index{Capri!constructor} \ 
    \\
    The given {\em Prolog\_Code}\/ is integrated into the target program.

    \begin{BoxedSample}
      constructor(writeln('Hello world.'))%
    \end{BoxedSample}


  \item [get(path, {\em Path})]\index{Capri!get path}\ 
    \\
    {\em Path}\/ is unified with the current path.

    This can be used to get the current path in order to restore it
    later. Such a situation is shown in the next example:

    \begin{BoxedSample}
      get(path,Path),
      template(Literal,extension),
      use\_path(Path),
      template(AnotherLiteral,residue)%
    \end{BoxedSample}
 

  \item [get(depth, {\em Depth})]\index{Capri!get depth}\ 
    \\
    {\em Depth}\/ is unified with the current depth.

    Note that the depth is not neccesarily a number. It may also be a Prolog
    term which is used by the search strategy to perform its task.

  \item [get(functor({\em Pred}), {\em Functor/Arity})]%
    \index{Capri!get functor}\ 
    \\
    This instruction unifies the literal {\em Pred}\/ with the literal
    having the functor {\em Functor}\/ and the arity {\em Arity}. This can be
    used to extract the functor and arity from a literal --- which has an
    additional sign. Alternatively it can be used to construct a literal. In
    this case the sign is |++|.

    The following example will unify |F/A| with |p/2|:
    \begin{BoxedSample}
      get(functor(++p(X,f(23)),F/A))%
    \end{BoxedSample}

    The following example will unify |L| with |++q(_,_,_)|:
    \begin{BoxedSample}
      get(functor(L,q/3))%
    \end{BoxedSample}

  \item [get(literals, {\em ListOfLiterals})]\index{Capri!get literals}\ 
    \\
    {\em ListOfLiterals}\/ is unified with the list of all literals occuring
    in the current matrix. The complete literals --- including sign and
    arguments --- are returned.


  \item [get(predicates, {\em ListOfPredicates})]\index{Capri!get predicates}\
    \\
    {\em ListOfPredicates} is unified with the list of (signed) functors. Each
    element has either the form |(-F)/A| for negative literals or |F/A| for
    positive literals, where |F| is a functor and |A| its arity.

    Consider a matrix containing only positive and negative occurrences of the
    predicate p/1. Then in the following example |PREDS| is unified with {\tt
      [(-p)/1,p/1]}.
    \begin{BoxedSample}
      get(predicates,PREDS)%
    \end{BoxedSample}

%  \item [get(functors, {\em ListOfFunctors})]\index{Capri!get functors}\ 
%    \\
%    {\em ListOfFunctors}

  \item [get(contrapositive({\em Index}), {\em
      Contrapositive})]\index{Capri!get contrapositive}\ \\
    {\em Contrapositive}\/ is unified with the contrapositive having the index
    {\em Index}. This can be used to get a contrapositive with a specified
    index or to get all contrapositives --- upon backtracking.

  \item [get(solved\_goals, {\em ListOfGoals})]\index{Capri!get solved goals}\
    \\
    {\em ListOfGoals}\/ is unified with the list of the goals already solved.

    {\bf NOT YET!}

  \item [get(open\_goals, {\em ListOfGoals})]\index{Capri!get open goals}\ 
    \\
    {\em ListOfGoals}\/ is unified with the list of open goals.

    {\bf NOT YET!}

  \item [put\_on\_path({\em Literal},{\em Info})]\index{Capri!put on path}\ 
    \\
    {\em Literal + Info }\/ is put on the path at this place. To prevent the
    automatic placement of a literal on the path the option
    |ProCom:automatic_put_on_path| can be used.

    \begin{BoxedSample}
      get(path,Path),
      get(depth,Depth),
      put\_on\_path(SomeLiteral,Depth),
      template(Literal,extension),
      use\_path(Path)%
    \end{BoxedSample}
 
  \item [put\_on\_path({\em Literal})]\index{Capri!put on path}\ 
    \\
    {\em Literal}\/ is put on the path at this place. To prevent the automatic
    placement of a literal on the path the option
    |ProCom:automatic_put_on_path| can be used. If no info is given (see
    above) then a new variable is used instead.

    \begin{BoxedSample}
      get(path,Path),
      put\_on\_path(SomeLiteral),
      template(Literal,extension),
      use\_path(Path)%
    \end{BoxedSample}
 
  \item [use\_path({\em Path})]\index{Capri!use path}\ 
    \\
    {\em Path}\/ is used as the path from this time on.  Note that you can not
    rely on any specific format of the path. The only save value for {\em
      Path} is the value of |get/path| or |empty_path|

    \begin{BoxedSample}
      get(path,Path),
      template(Literal,extension),
      use\_path(Path),
      template(AnotherLiteral,residue)%
    \end{BoxedSample}
 
\end{description}

To end this part we will show a complete \CaPrI{} descriptor module. It
implements the well known model elimination calculus. The first descriptor
encodes the reduction step and the second descriptor encodes the extension
step. In both cases the appropriate information for the proof tree is
provided. 

\begin{BoxedSample}
:- module(my\_own\_calculus).
:- compile(capri).

descriptor
        proof(reduction(Pred)),
        template(Pred,goal),
        template(-Pred,path).

descriptor
        proof(extension(-Pred)),
        template(Pred,goal),
        template(-Pred,extension).
\end{BoxedSample}

\iffalse
\subsection{Before and After Descriptors}

\begin{description}
  \item [start\_descriptor]\ \\
	This descriptor is evaluated once before ...

  \item [end\_descriptor]\ \\
	This descriptor is evaluated once after ...
\end{description}

\subsection{Static Reordering}

These features are not implemented yet. 

\begin{description}
  \item [compare\_literals(L1,L2).]\ \\
	Reordering literals

  \item [compare\_clauses(C1,C2).]\ \\
	Reordering clauses
\end{description}

\fi


\subsection{Testing and Modifying Options}

A certain prover may require some options to be set to given values or fit in
a given scheme. E.g. the target language has to be Quintus prolog since a
library is only written for this dialect.

To accomplish this instructions are provided to test and modify options. For a
detailed description which options are predefined see section
\ref{sec:options}.

\begin{description}
  \item [force\_option({\em Option}, {\em
  ListOfValues}).]\index{force\_option}\ \\
	This instruction describes which values of options are allowed. The
	elements os the list {\em ListOfValues} are unified with the actual
	value of {\em Option} until a match is found. 

	If no candidate unifies then the first element of the list is taken as
	the value of {\em Option}.

	This directive is evaluated before the compilation is started.
	I.e. the matrix has already been read and no preprocessing has been
	performed. 

	As an example consider the following instruction:

\begin{BoxedSample}
  force\_option(prolog, [quintus]).
\end{BoxedSample}

	This instruction forces the generation of Prolog code in the target
	language Quintus Prolog.

  \item [require\_option({\em Option}, {\em ListOfValues}).]%
	\label{require_option}\ \\
	This instruction describes requirements for options without the
	possibility to revert the option to a default value. 
	If one of these instructions is incompatible with the actual value of
	an option then no compilation is performed.

	For instance consider the following instruction which forces that the
	option |equality| is off.

\begin{BoxedSample}
  require\_option(equality, [off]).
\end{BoxedSample}

\end{description}


\subsection{Adjusting the Linker}

The linker tries to add definitions for missing Prolog predicates. For this
purpose it scans libraries and adds those libraries containing the appropriate
definitions. 

It can be desirable to replace given libraries, e.g. to use an improved
version of the debugger. This can partially be done by modifying options. This
section provides instructions to perform tasks which can hardly be solved by
modifying options.

\begin{description}
  \item [require\_predicate({\em Predicate}).]\index{require\_predicate}\ \\
	This instruction tells the linker that the predicate {\em Predicate}\/
	is required and a appropriate definition should be linked. {\em
	Predicate}\/ is a predicate specification of the form {\em
	Name/Arity}\/ like in the following example

\begin{BoxedSample}
  require(paramodulate/4).
\end{BoxedSample}

  \item [library\_file({\em File}).]\index{library\_file}\ \\
	This instruction tells the linker to consider the file {\em File} to
	find additional Prolog code.

\begin{BoxedSample}
  library\_file(my\_debugger).
\end{BoxedSample}

  \item [library\_path({\em ListOfDirectories}).]\index{library\_path}\ \\
	This instruction prepends the list of directories {\em
	ListOfDirectories} in front of the search path for libraries as in

\begin{BoxedSample}
  library\_path(['../my\_trash']).
\end{BoxedSample}

  \item [provide\_definition({\em Code}).]\index{provide\_definition}\ \\
	This instruction provides the linker with additional Prolog code which
	may be included. The {\em Code}\/ is a list of Prolog clauses which
	are added to the target program when required.

	This is only recommended for small pieces of Prolog. Consider the use
	of a library instead.
\end{description}

