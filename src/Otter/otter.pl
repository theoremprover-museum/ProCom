%%*****************************************************************************
%% $Id: otter.pl,v 1.10 1995/03/23 14:04:39 gerd Exp $
%%*****************************************************************************
%%% 
%%% This file is part of ProCom.
%%% It is distributed under the GNU General Public License.
%%% See the file COPYING for details.
%%% 
%%% (c) Copyright 1995 Gerd Neugebauer
%%% 
%%% Net: gerd@imn.th-leipzig.de
%%% 
%%%****************************************************************************

:- module_interface(otter). /*%------------------------------------------------
\FileId{Gerd Neugebauer}{\RCSstrip$Revision: 1.10 $}

This module provides an interface to the theorem prover otter. An externally
existing version of otter is assumed. At least version 3.0 of otter is
required.

\PL*/
:- export otter/0,
	  otter/1.
:- begin_module(otter).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The module has to be identified for \ProTop.

\PL*/
info(prover,
	"$Revision: 1.10 $",
	"The prover module otter provides an interface to the external prover otter.").
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\PL*/
:-	lib(lists),
	lib(numbervars).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\PL*/
:-	lib(os),
	lib(find_file),
	lib(message),
	lib(options),
	lib(hook),
	lib(matrix),
	lib(literal).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Load the configuration file. This should define a single fact for the
predicate |define_otter/1|.

\PL*/
:- compile('otter.cfg').
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate define_otter/1(+Directory).

This predicate is defined in the configuration file.  The argument |Directory|
is a string naming the otter executable.

\PL*/
:- define_otter(Executable),
   (define_option 'otter:executable'	 = Executable).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option  |otter:executable| contains the name  of the  otter program. It is
initialized from the default value specified in	 the configuration file (which
in turn might be generated by a Makefile).

\PL*/
:- define_option 'otter:flags'		 = [auto,-print_given].
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option |otter:flags|  contains a list  of options to  be included into the
otter input file. A flag can be an atom. In this  case the otter flag with the
same name is turned on.	 A flag can  be a atom preceeded by  |-|. In this case
the otter flag	is turned off. Finally	a flag can be  set to a specific value
with the instruction {\it flag |=| value}.

\PL*/
:- define_option 'otter:tmpdirs'	 = [indir,".","/tmp","~"].
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option |otter:tmpdirs| contains a list of directories which are considered
for generating intermediate files.   |indir| denotes the  directory containing
the input file.

\PL*/
:- define_option 'otter:remove_tmp_files' = off.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The  option |otter:remove_tmp_files|  controlls	 wether the intermediate files
generated for or by otter are removed afterwards.

\PL*/
main_read_matrix_hook :-
	is_option(prover,P),
	functor(P,otter,_),
        is_option(equality),
	set_option(remove_unreached_clauses=off),
	!.

:- hook(main_read_matrix,main_read_matrix_hook/0).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\bigskip


\Predicate otter/1(+FlagsList).

This predicate starts otter with the flags specified in the argument
|FlagsList|. |FlagsList| is stored in the option |otter_flags| and the
predicate |otter/0| is called to perform the real task.

\PL*/
otter(Flags) :-
	set_option('otter_flags'=Flags),
	otter.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter/0().

This predicate runs the external prover otter. The matrix is  stored in a file
such that otter	 can read it. The otter	 program is executed and the resulting
output file  is	 analyzed to transform	 the informations stored there	into a
format suitable for \ProTop.

\PL*/
otter :-
	otter_determine_files(InFile,OutFile),
	open(InFile,write,Stream),
	otter_preamble(Stream),
	otter_save_matrix(Stream),
	close(Stream),
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\PL*/
	is_option('otter:executable',Otter),
	( execute([Otter," <",InFile," >",OutFile]) -> true; true ),
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\PL*/
	is_option(log_file,LogFile),
	( empty_option(LogFile) ->
	    LogStream = output
	;   open(LogFile,append,LogStream)
	),
	open(OutFile,read,Stream2),
	otter_analyze(Stream2,LogStream),
	close(Stream2),
	( LogStream == output ->
	    true
	;   close(LogStream)
	),
	( is_option('otter:remove_tmp_files') ->
	    delete_file(InFile),
	    delete_file(OutFile)
	;   true
	),
	!.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_determine_files/2(-InFile, -OutFile).

Otter requires two files to be specified. The file |InFile| contains the flags
and the problem. By convention it has the extension {\sf .in}. The file
|OutFile| is used to hold the results. It has the extension {\sf .out}.

This predicate tries to figure out sensible values for those files.

\PL*/
otter_determine_files(InFile,OutFile) :-
	is_option(input_path,Path),
	is_option(input_extensions,Extensions),
	( is_option(input_file,Input_File),
	  Input_File \== [],
	  find_file(Input_File,['.'|Path],[''|Extensions],F) ->
	    pathname(F,In_Dir,In_Name),
	    ( string_length(In_Dir,0) ->
		InDirectory = "./"
	    ;	InDirectory = In_Dir
	    )
	;   InDirectory = "./"
	),
	    
	is_option('otter:tmpdirs',DirList),
	( member(Directory,DirList) ->
	    ( Directory == indir ->
		Dir = InDirectory
	    ;	Dir = Directory
	    ),
	    get_file_info(Dir,readable,on),
	    get_file_info(Dir,writable,on),
	    get_file_info(Dir,executable,on)
	;   Dir = "/tmp/"
	),

	concat_string([Dir,In_Name,".in"  ], InFile),
	concat_string([Dir,In_Name,".out" ],OutFile).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_preamble/1(+Stream).

This predicate generates a preamble of an otter input file. The preamble is
written onto the stream |Stream|. A preamble contains the settings of otter
flags. The default values as stored in the Prolog fact |otter_flag/1| are
written out in a failure driven loop. The same technique is used to write out
the flags stored in the option |otter:flags|.

\PL*/
otter_preamble(Stream) :-
	(   otter_flag(Flag,Type),
	    ( Type == set ->
		printf(Stream,"set(%w).\n",[Flag])
	    ; Type == clear ->
		printf(Stream,"clear(%w).\n",[Flag])
	    ; integer(Type) ->
		printf(Stream,"assign(%w,%w).\n",[Flag,Type])
	    ),
	    fail
	;   nl(Stream)
	),
	is_option('otter:flags',Flags),
	(   member(Flag,Flags),
	    ( Flag = (A=B) ->
		otter_numeric_flag(A,B,Stream)
	    ; Flag = -F ->
		otter_boolean_flag(F,clear,Stream)
	    ;	otter_boolean_flag(Flag,set,Stream)
	    ),
	    fail
	;   nl(Stream)
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_numeric_flag/3(+Flag, +Value, +Stream).

This predicate writes out a numeric otter flag onto the stream |Stream|. The
flag is cheched to be a proper flag and the value beeing in an appropriate
range.

\PL*/
otter_numeric_flag(Flag,Value,Stream) :-
	( \+ integer(Value) ->
	    err("*** Otter flag has wrong type of value. Integer expected:",
	        Value)
	;
	  otter_flag(Flag,Type) ->
	    ( Type = integer ->
		printf(Stream,"assign(%w,%w).\n",[Flag,Value])
	    ; Type = integer(L,H) ->
		( B >= L, B =< H ->
		    printf(Stream,"assign(%w,%w).\n",[Flag,Value])
		;   err("*** Otter flag ",Flag," is out of range: ",[L,H]),
		    fail
		)
	    ; integer(Type) ->
		( Type = Value ->
		    msg("--- Otter flag ",Flag," is set to its default.")
		;   err("*** Otter flag ",Flag," is locked."),
		    fail
		)
	    ;	err("*** Otter flag ",Flag," is not numeric."),
		fail
	    )
	;   err("*** Otter flag ",Flag," is unknown"),
	    fail
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_boolean_flag/3(+Flag, +Value, +Stream).

This predicate writes out a boolean otter flag onto the stream |Stream|. The
flag is cheched to be a proper flag.

\PL*/
otter_boolean_flag(Flag,Value,Stream) :-
	( otter_flag(Flag,Type) ->
	    ( Type == boolean ->
		printf(Stream,"%w(%w).\n",[Value,Flag])
	    ; Type = Value ->
		msg("--- Otter flag ",Flag," is set to its default.")
	    ; ( functor(Type,integer,_)
	      ; integer(Type) ) ->
		err("*** Otter flag ",Flag," is not boolean."),
		fail
	    ;
		err("*** Otter flag ",Flag," is locked."),
		fail
	    )
	;   err("*** Otter flag ",Flag," is unknown"),
	    fail
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_flag/2(Flag,Type).

This predicate lists all legal otter flags ad their type. |Flag| is an atom
according to the specification of otter flags. See the documentation of otter
for further details.

|Type| can have one of the following values:
\begin{description}
\item [boolean] denotes a boolean flag. it can be turned on or off.
\item [set] denotes a boolean flag which must be turned on.
\item [clear] denotes a boolean flag which must be turned off.
\item [default] denotes a flag which can not be changed.
\item [integer] denotes a numeric flag which can take arbitrary values.
\item [integer({\it min},{\it max})] denotes a numeric flag which can take
  values in the range from {\it min}\/ to {\it max}. 
\end{description}

\PL*/
otter_flag(auto				,boolean).
otter_flag(sos_queue			,boolean).
otter_flag(sos_stack			,boolean).
otter_flag(input_sos_first		,boolean).
otter_flag(interactive_given		,default).
otter_flag(print_given			,boolean).
otter_flag(print_lists_at_end		,boolean).
otter_flag(binary_res			,boolean).
otter_flag(hyper_res			,boolean).
otter_flag(neg_hyper_res		,boolean).
otter_flag(ur_res			,boolean).
otter_flag(para_into			,boolean).
otter_flag(para_from			,boolean).
otter_flag(demod_inf			,boolean).
otter_flag(para_from_left		,boolean).
otter_flag(para_from_right		,boolean).
otter_flag(para_into_left		,boolean).
otter_flag(para_into_right		,boolean).
otter_flag(para_from_vars		,boolean).
otter_flag(para_into_vars		,boolean).
otter_flag(para_from_units_only 	,boolean).
otter_flag(para_into_units_only 	,boolean).
otter_flag(para_skip_skolem		,boolean).
otter_flag(para_ones_rule		,boolean).
otter_flag(para_all			,boolean).
otter_flag(detailed_history		,boolean).
otter_flag(order_history		,boolean).
otter_flag(unit_deletion		,boolean).
otter_flag(delete_identical_nested_skolem,boolean).
otter_flag(sort_literals		,boolean).
otter_flag(for_sub			,boolean).
otter_flag(back_sub			,boolean).
otter_flag(factor			,boolean).
otter_flag(demod_history		,boolean).
otter_flag(order_eq			,boolean).
otter_flag(eq_units_both_ways		,boolean).
otter_flag(demod_linear			,boolean).
otter_flag(demod_out_in			,boolean).
otter_flag(dynamic_demod		,boolean).
otter_flag(dynamic_demod_all		,boolean).
otter_flag(dynamic_demod_lex_dep	,boolean).
otter_flag(back_demod			,boolean).
otter_flag(knuth_bendix			,boolean).
otter_flag(lrpo				,boolean).
otter_flag(lex_order_vars		,boolean).
otter_flag(symbol_elim			,boolean).
otter_flag(check_arity			,boolean).
otter_flag(prolog_style_variables	,set).
otter_flag(echo_included_files		,boolean).
otter_flag(simplify_fol			,boolean).
otter_flag(process_input		,boolean).
otter_flag(very_verbose			,default).
otter_flag(print_kept			,clear).
otter_flag(print_proofs			,default).
otter_flag(print_new_demod		,boolean).
otter_flag(print_back_demod		,boolean).
otter_flag(print_back_sub		,boolean).
otter_flag(display_terms		,default).
otter_flag(pretty_print			,default).
otter_flag(bird_print			,default).
otter_flag(index_for_back_demod 	,boolean).
otter_flag(for_sub_fpa			,boolean).
otter_flag(no_fapl			,boolean).
otter_flag(no_fanl			,boolean).
otter_flag(control_memory		,boolean).
otter_flag(order_hyper			,boolean).
otter_flag(propositional		,default).
otter_flag(really_delete_clauses	,default).
otter_flag(atom_wt_max_args		,boolean).
otter_flag(term_wt_max_args		,boolean).
otter_flag(free_all_mem			,boolean).
otter_flag(report			,integer).
otter_flag(max_seconds			,integer).
otter_flag(max_gen			,integer).
otter_flag(max_kept			,integer).
otter_flag(max_given			,integer).
otter_flag(max_mem			,integer).
otter_flag(max_literals			,integer).
otter_flag(max_weight			,integer).
otter_flag(max_distinct_vars		,integer).
otter_flag(fpa_literals			,integer(0,100)).
otter_flag(fpa_terms			,integer(0,100)).
otter_flag(pick_given_ratio		,integer).
otter_flag(interrupt_given		,default).
otter_flag(demod_limit			,integer).
otter_flag(max_proofs			,integer).
otter_flag(min_bit_width		,integer).
otter_flag(neg_weight			,integer).
otter_flag(pretty_print_indent		,integer(4,16)).
otter_flag(stats_level			,default).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_save_matrix/1(+Stream).

This predicate writes the current matrix onto the stream |Stream|. This is
done in a format suitable for otter.

\PL*/
otter_save_matrix(Stream) :-
	printf(Stream,"list(usable).\n",[]),
	(   'Clause'(Index,[literal(Lit,_)|Rest]),
	    numbervars(Lit+Rest,0,_),
	    printf(Stream,"\n%%	 Clause %w\n",[Index]),
	    otter_save_literal(Lit,Stream),
	    (	member(literal(L,_),Rest),
		printf(Stream," |\n\t",[]),
		otter_save_literal(L,Stream),
		fail
	    ;	true
	    ),
	    printf(Stream,".\n",[]),
	    fail
	;   true
	),
	printf(Stream,"end_of_list.\n\n",[]).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_save_literal/2(+Literal, +Stream).

Thispredicate writes out a single literal |Litreral| onto the stream |Stream|
in the otter format. Otter uses no sign for positive literals and the |-| sign
for negative literals.

\PL*/
otter_save_literal(++Lit,Stream) :-
	printf(Stream,"%DQw",[Lit]).
otter_save_literal(--Lit,Stream) :-
	( Lit = (L=R) ->
	    printf(Stream,"%DQw != %DQw",[L,R])
	;   printf(Stream,"- %DQw",[Lit])
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The otter proof contains terms with the operator |$/1|. Thus we have to define
it.

\PL*/
:-	op(300,fx,($)),
	op(700,xfx,'!=').
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


\PL*/
:- dynamic 'otter proof'/3,
	   'otter proof'/1.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_analyze/2(+Stream, +Report).

This predicate analyzes the otter output information and extracts the relevant
values. Those values are stored in the \ProTop{} report file.

\PL*/
otter_analyze(Stream,Report) :-
	repeat,
	( at_eof(Stream) ->
	    true
	;
	    read_string(Stream,"\n",_,String),
	    string_length(String) >= 10,
	    substring(String,"----------",1),
	    otter_analyze(String,Stream,Report),
	    fail
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_analyze/3(+String, +Stream, +Report).

\PL*/
otter_analyze(String,Stream,Report) :-
	( substring(String,"times",_) ->
	    otter_analyze_times(Stream,Report)
	; substring(String,"PROOF",_) ->
	    otter_analyze_proof(Stream,Report)
	;   true
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_analyze_proof/2(+Stream, +Report).

\PL*/
otter_analyze_proof(Stream,Report) :-
	nl,
	retract_all('otter proof'(_,_,_)),
	retract_all('otter proof'(_)),
	repeat,
	read_string(Stream,"\n",_,String),
	( string_length(String,0) ->
	    fail
	; substring(String,"---",1) ->
	    true
	;   otter_analyze_proof_step(String),
	    writeln(String),
	    fail
	),
	!,
	nl,
	'otter proof'(L,S,($_)),
	otter_analyze_proof_term(S,L,'$F',Proof),
	printf(Report,"proof(false,%DQw).\n\n",Proof),
	writeln(valid).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_analyze_proof_step/1(+String).

\PL*/
otter_analyze_proof_step(S) :-
	otter_replace_eq(S,String),
	substring(String," [",Pos1),
	substring(String,"] ",Pos2),
	substring(String,1,Pos1,S1),
	term_string(T1,S1),

	L2 is Pos2-Pos1+1,
	substring(String,Pos1,L2,S2),
	term_string(T2,S2),
	
	L3 is string_length(String)-Pos2-1,
	Pos3 is Pos2+1,
	substring(String,Pos3,L3,S3),
	term_string(T3,S3),
	
	assert('otter proof'(T1,T2,T3)).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_replace_eq/2(+S, ?Snew).

\PL*/
otter_replace_eq(S,Snew) :-
	(   substring(S,"!=",P) ->
	      P1 is P-1,
	      substring(S,1,P1,S1),
	      P2 is P+2,
	      P3 is string_length(S)-P2+1,
	      substring(S,P2,P3,S2),
	      concat_string([S1,"~=",S2],S3),
	      otter_replace_eq(S3,Snew)
	;   substring(S,".",P) ->
	      P1 is P-1,
	      substring(S,1,P1,S1),
	      P2 is P+1,
	      P3 is string_length(S)-P2+1,
	      substring(S,P2,P3,S2),
	      concat_string([S1,"/",S2],S3),
	      otter_replace_eq(S3,Snew)
	;   S = Snew
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_analyze_proof_term/4(List, Label, Clause, Proof).

\PL*/
otter_analyze_proof_term(_,Label,_,Proof) :-
	'otter proof'(Label),
	!,
	Proof = '*'(Label).
otter_analyze_proof_term([],Label,Clause,input(Label,Clause)) :-
	assert('otter proof'(Label)).
otter_analyze_proof_term([Step|Args],Label,Clause,Proof) :-
	assert('otter proof'(Label)),
	otter_analyze_proof_term_subproofs(Args,Subproofs),
	Proof =.. [Step,Label,Clause|Subproofs].
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_analyze_proof_term_subproofs/2(List, Proof).

\PL*/
otter_analyze_proof_term_subproofs([],[]).
otter_analyze_proof_term_subproofs([H|T],[SH|ST]) :-
	( 'otter proof'(H,Step,Clause) ->
	    L = H
	; real(H), fix(H,L),'otter proof'(L,Step,Clause) ->
	    true
	),
	otter_analyze_proof_term(Step,L,Clause,SH),
	otter_analyze_proof_term_subproofs(T,ST).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate otter_analyze_times/2(+Stream, +Report).

\PL*/
otter_analyze_times(Stream,Report) :-
	repeat,
	( at_eof(Stream) ->
	    true
	;
	    read_string(Stream,"\n",_,String),
	    string_length(String,L),
	    ( L == 0 ->
		true
	    ;
		L >= 20,
		substring(String,1,20,Type),
		substring(String,21,7,T),
		term_string(Ti,T),
		Tim is Ti*1000,
		fix(Tim,Time),
		( Report = output ->
		    true
		;   printf(Report,"time(%q,%w).\n",[Type,Time])
		),
		printf("%w%8d ms\n",[Type,Time]),
		fail
	    )
	),
	!.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
\EndProlog */
