%%*****************************************************************************
%% $Id: protein.pl,v 1.1 1995/01/27 13:45:38 gerd Exp $
%%*****************************************************************************
%%% 
%%% This file is part of ProCom.
%%% It is distributed under the GNU General Public License.
%%% See the file COPYING for details.
%%% 
%%% (c) Copyright 1995 Gerd Neugebauer
%%% 
%%% Net: gerd@imn.th-leipzig.de
%%% 
%%%****************************************************************************

:- module_interface(protein). /*%----------------------------------------------
\FileId{Gerd Neugebauer}{\RCSstrip$Revision: 1.1 $}

This module provides an interface to the theorem prover protein. An externally
existing version of protein is assumed. At least version 1.1 of protein is
required.

\PL*/
:- export protein/0,
	  protein/1.
:- begin_module(protein).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\PL*/
info(prover,"$Revision: 1.1 $","Protein interface for ProTop.").
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\PL*/
:-	lib(lists).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\PL*/
:-	lib(os),
	lib(find_file),
	lib(message),
	lib(options),
	lib(matrix),
	lib(literal).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Load the configuration file. This should define a single fact for the
predicate |define_protein/1|.

\PL*/
:- compile('protein.cfg').
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate define_protein/1(+Directory).

This predicate is defined in the configuration file.  The argument |Directory|
is a string naming the protein executable.

\PL*/
:- define_protein(Executable),
   (define_option 'protein:executable'	 = Executable).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option |protein:executable| contains the name of the protein program. It
is initialized from the default value specified in the configuration file
(which in turn might be generated by a Makefile).

\PL*/
:- define_option 'protein:flags'		 = [trace].
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option |protein:flags| contains a list of options to be included into the
protein input file. A flag can be an atom. In this case the protein flag with
the same name is turned on. A flag can be a atom preceeded by |-|. In this
case the protein flag is turned off. Finally a flag can be set to a specific
value with the instruction {\it flag |=| value}.

\PL*/
:- define_option 'protein:tmpdirs'	 = [indir,".","/tmp","~"].
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option |protein:tmpdirs| contains a list of directories which are
considered for generating intermediate files. |indir| denotes the directory
containing the input file.

\PL*/
:- define_option 'protein:remove_tmp_files' = off.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option |protein:remove_tmp_files| controlls wether the intermediate files
generated for or by protein are removed afterwards.  \bigskip


\Predicate protein/1(+FlagsList).

This predicate	 starts protein with the flags specified in the argument
|FlagsList|.  |FlagsList| is stored in the option |protein_flags|.

\PL*/
protein(Flags) :-
	set_option('protein_flags'=Flags),
	protein.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein/0().

This predicate runs the external prover protein. The matrix is  stored in a file
such that protein	 can read it. The protein	 program is executed and the resulting
output file  is	 analyzed to transform	 the informations stored there	into a
format suitable for \ProTop.

\PL*/
protein :-
	protein_determine_files(InFile,OutFile),
	open(InFile,write,Stream),
	protein_preamble(Stream),
	protein_save_matrix(Stream),
	close(Stream),
	is_option('protein:executable',Protein),
	concat_string([Protein," ",InFile," >",OutFile],Cmd),
	( system(Cmd) -> true; true ),
	open(OutFile,read,Stream2),
	protein_analyze(Stream2,output),
	close(Stream2),
	( is_option('protein:remove_tmp_files') ->
	    delete_file(InFile),
	    delete_file(OutFile)
	;   true
	),
	!.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_determine_files/2(-InFile, -OutFile).

Protein requires two files to be specified. The file |InFile| contains the
flags and the problem. By convention it has the extension {\sf .tme}. The file
|OutFile| is used to hold the results. It has the extension {\sf .tme-log}.

This predicate tries to figure out sensible values for those files.

\PL*/
protein_determine_files(InFile,OutFile) :-
	is_option(input_path,Path),
	is_option(input_extensions,Extensions),
	( is_option(input_file,Input_File),
	  Input_File \== [],
	  find_file(Input_File,['.'|Path],[''|Extensions],F) ->
	    pathname(F,In_Dir,In_Name),
	    ( string_length(In_Dir,0) ->
		InDirectory = "."
	    ;	InDirectory = In_Dir
	    )
	;   InDirectory = "."
	),
	    
	is_option('protein:tmpdirs',DirList),
	( member(Directory,DirList) ->
	    ( Directory == indir ->
		Dir = InDirectory
	    ;	Dir = Directory
	    ),
	    get_file_info(Dir,readable,on),
	    get_file_info(Dir,writable,on),
	    get_file_info(Dir,executable,on)
	;   Dir = "/tmp"
	),

	concat_string([Dir,"/",In_Name,".tme"  ], InFile),
	concat_string([Dir,"/",In_Name,".tme-log" ],OutFile).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_preamble/1(+Stream).

This predicate generates a preamble of an protein input file. The preamble is
written onto the stream |Stream|. A preamble contains the settings of protein
flags. The default values as stored in the Prolog fact |protein_flag/1| are
written out in a failure driven loop. The same technique is used to write out
the flags stored in the option |protein:flags|.

\PL*/
protein_preamble(Stream) :-
	(   protein_flag(Flag,Type),
	    ( Type == set ->	printf(Stream,"set(%w).\n",[Flag])
	    ; Type == clear ->	printf(Stream,"clear(%w).\n",[Flag])
	    ; integer(Type) ->	printf(Stream,"assign(%w,%w).\n",[Flag,Type])
	    ),
	    fail
	;   nl(Stream)
	),
	is_option('protein:flags',Flags),
	(   member(Flag,Flags),
	    ( Flag = (A=B) ->
		protein_numeric_flag((A=B),Stream)
	    ; Flag = -F ->
		protein_boolean_flag(F,clear,Stream)
	    ;	protein_boolean_flag(Flag,set,Stream)
	    ),
	    fail
	;   nl(Stream)
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_numeric_flag/2(+Flag, +Stream).

This predicate writes out a numeric protein flag onto the stream |Stream|. The
flag is cheched to be a proper flag and the value beeing in an appropriate
range.

\PL*/
protein_numeric_flag((Flag=B),Stream) :-
	( \+ integer(B) ->
	    err("*** Protein flag has wrong type of value. Integer expected:",B)
	;
	  protein_flag(Flag,Type) ->
	    ( Type = integer ->
		printf(Stream,"assign(%w,%w).\n",[A,B])
	    ; Type = integer(L,H) ->
		( B >= L, B =< H ->
		    printf(Stream,"assign(%w,%w).\n",[A,B])
		;   err("*** Protein flag ",Flag," is out of range: ",[L,H]),
		    fail
		)
	    ; integer(Type) ->
		( Type = B ->
		    msg("--- Protein flag ",Flag," is set to its default.")
		;   err("*** Protein flag ",Flag," is locked."),
		    fail
		)
	    ;	err("*** Protein flag ",Flag," is not numeric."),
		fail
	    )
	;   err("*** Protein flag ",Flag," is unknown"),
	    fail
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_boolean_flag/3(+Flag, +Value, +Stream).

This predicate writes out a boolean protein flag onto the stream |Stream|. The
flag is cheched to be a proper flag.

\PL*/
protein_boolean_flag(Flag,Value,Stream) :-
	( protein_flag(Flag,Type) ->
	    ( Type == boolean ->
		printf(Stream,"%w(%w).\n",[Value,Flag])
	    ; Type = Value ->
		msg("--- Protein flag ",Flag," is set to its default.")
	    ; ( functor(Type,integer,_)
	      ; integer(Type) ) ->
		err("*** Protein flag ",Flag," is not boolean."),
		fail
	    ;
		err("*** Protein flag ",Flag," is locked."),
		fail
	    )
	;   err("*** Protein flag ",Flag," is unknown"),
	    fail
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_flag/2(Flag,Type).

This predicate lists all leagal protein flags ad their type. |Flag| is an atom
according to the specification of protein flags. See the documentation of protein
for further details.

|Type| can have one of the following values:
\begin{description}
\item [boolean] denotes a boolean flag. it can be turned on or off.
\item [set] denotes a boolean flag which must be turned on.
\item [clear] denotes a boolean flag which must be turned off.
\item [default] denotes a flag which can not be changed.
\item [integer] denotes a numeric flag which can take arbitrary values.
\item [integer({\it min},{\it max})] denotes a numeric flag which can take
  values in the range from {\it min}\/ to {\it max}. 
\end{description}

\PL*/
protein_flag(all_solutions		,default).
protein_flag(ancestry_restart_me	,default).
protein_flag(answer_set_handling	,default).
protein_flag(backfactor			,default).
protein_flag(backfactor_cut		,default).
protein_flag(definite_answers		,default).
protein_flag(equal_anc_check		,default).
protein_flag(equal_anc_delay		,default).
protein_flag(equality		,default).
protein_flag(eq_symm		,default).
protein_flag(eq_trans		,default).
protein_flag(eq_subst		,default).
protein_flag(iterative_deepening	,default).
protein_flag(more_solution		,default).
protein_flag(neg_anc_no		,default).
protein_flag(pos_anc_no		,default).
protein_flag(pos_anc_dj		,default).
protein_flag(reduction_cut		,default).
protein_flag(residue_chk		,default).
protein_flag(residue_chk_delay		,default).
protein_flag(restart_with_clause		,default).
protein_flag(selection_function		,default).
protein_flag(sorted_by_costs		,default).
protein_flag(strict_restart_me		,default).
protein_flag(th_nonewclauses		,default).
protein_flag(th_sidelit_anc		,default).
protein_flag(trace		,set).
protein_flag(unit_restart_me		,default).
protein_flag(verbose		,set).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_save_matrix/1(+Stream).

This predicate writes the current matrix onto the stream |Stream|. This is
done in a format suitable for protein.

\PL*/
protein_save_matrix(Stream) :-
	printf(Stream,"list(usable).\n",[]),
	(   'CP_by_index'(Idx,1,Lit,Rest),
	    printf(Stream,"\n%%	 Clause %w\n",[Idx]),
	    protein_save_literal(Lit,Stream),
	    (	member(literal(L,_),Rest),
		printf(Stream," |\n\t",[]),
		protein_save_literal(L,Stream),
		fail
	    ;	true
	    ),
	    printf(Stream,".\n",[]),
	    fail
	;   true
	),
	printf(Stream,"end_of_list.\n\n",[]).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_save_literal/2(+Literal, +Stream).

Thispredicate writes out a single literal |Litreral| onto the stream |Stream|
in the protein format. Protein uses no sign for positive literals and the |-| sign
for negative literals.

\PL*/
protein_save_literal(++Lit,Stream) :-
	printf(Stream,"%w",[Lit]).
protein_save_literal(--Lit,Stream) :-
	printf(Stream,"- %w",[Lit]).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The protein proof contains terms with the operator |$/1|. Thus we have to define
it.

\PL*/
:- op(300,fx,($)).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


\PL*/
:- dynamic 'protein proof'/3,
	   'protein proof'/1.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_analyze/2(+Stream, +Report).

This predicate analyzes the protein output information and extracts the relevant
values. Those values are stored in the \ProTop{} report file.

\PL*/
protein_analyze(Stream,Report) :-
	repeat,
	( at_eof(Stream) ->
	    true
	;
	    read_string(Stream,"\n",_,String),
	    string_length(String) >= 10,
	    substring(String,"----------",1),
	    protein_analyze(String,Stream,Report),
	    fail
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_analyze/3().

\PL*/
protein_analyze(String,Stream,Report) :-
	( substring(String,"times",_) ->
	    protein_analyze_times(Stream,Report)
	; substring(String,"PROOF",_) ->
	    protein_analyze_proof(Stream,Report)
	;   true
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_analyze_proof/2().

\PL*/
protein_analyze_proof(Stream,Report) :-
	retract_all('protein proof'(_,_,_)),
	retract_all('protein proof'(_)),
	repeat,
	read_string(Stream,"\n",_,String),
	( string_length(String,0) ->
	    fail
	; substring(String,"---",1) ->
	    true
	;   protein_analyze_proof_step(String),
	    fail
	),
	!,
	'protein proof'(L,S,($_)),
	protein_analyze_proof_term(S,L,'$F',Proof),
	printf(Report,"proof(false,%DQw).\n\n",Proof).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_analyze_proof_step/1().

\PL*/
protein_analyze_proof_step(String) :-
	substring(String," [",Pos1),
	substring(String,"] ",Pos2),
	substring(String,1,Pos1,S1),
	term_string(T1,S1),

	L2 is Pos2-Pos1+1,
	substring(String,Pos1,L2,S2),
	term_string(T2,S2),
	
	L3 is string_length(String)-Pos2-1,
	Pos3 is Pos2+1,
	substring(String,Pos3,L3,S3),
	term_string(T3,S3),
	
	assert('protein proof'(T1,T2,T3)).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_analyze_proof_term/4(List, Label, Clause, Proof).

\PL*/
protein_analyze_proof_term(_,Label,_,Proof) :-
	'protein proof'(Label),
	!,
	Proof = '*'(Label).
protein_analyze_proof_term([],Label,Clause,input(Label,Clause)) :-
	assert('protein proof'(Label)).
protein_analyze_proof_term([Step|Args],Label,Clause,Proof) :-
	assert('protein proof'(Label)),
	protein_analyze_proof_term_subproofs(Args,Subproofs),
	Proof =.. [Step,Label,Clause|Subproofs].
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_analyze_proof_term_subproofs/2(List, Proof).

\PL*/
protein_analyze_proof_term_subproofs([],[]).
protein_analyze_proof_term_subproofs([H|T],[SH|ST]) :-
	'protein proof'(H,Step,Clause),
	protein_analyze_proof_term(Step,H,Clause,SH),
	protein_analyze_proof_term_subproofs(T,ST).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate protein_analyze_times/2(+Stream, +Report).

\PL*/
protein_analyze_times(Stream,Report) :-
	repeat,
	( at_eof(Stream) ->
	    true
	;
	    read_string(Stream,"\n",_,String),
	    string_length(String,L),
	    ( L == 0 ->
		true
	    ;
		L >= 20,
		substring(String,1,20,Type),
		substring(String,21,7,T),
		term_string(Ti,T),
		Tim is Ti*1000,
		fix(Tim,Time),
		printf(Report,"time(%q,%w).\n",[Type,Time]),
		fail
	    )
	),
	!.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
\EndProlog */
