%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% $Id: setheo.pl,v 1.7 1995/03/20 21:24:47 gerd Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 
%%% This file is part of ProCom.
%%% It is distributed under the GNU General Public License.
%%% See the file COPYING for details.
%%% 
%%% (c) Copyright 1995 Gerd Neugebauer
%%% 
%%% Net: gerd@imn.th-leipzig.de
%%% 
%%%****************************************************************************

:- module_interface(setheo). /*%-----------------------------------------------
\FileId{Gerd Neugebauer}{\RCSstrip$Revision: 1.7 $}

This module provides an interface to the theorem prover setheo. An externally
existing version of setheo is assumed. At least version 3.0 of setheo is
required.

\PL*/
:- export setheo/0.
:- begin_module(setheo).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The module has to be identified for \ProTop.

\PL*/
info(prover,
	"$Revision: 1.7 $",
	"The prover module setheo provides an interface to the external prover setheo.").
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\PL*/
:-	lib(lists).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\PL*/
:-	lib(proof),
	lib(os),
	lib(find_file),
	lib(message),
	lib(options),
	lib(matrix),
	lib(literal).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Load the configuration file. This should define a single fact for the
predicate |define_setheo/1|.

\PL*/
:- compile('setheo.cfg').
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate define_setheo/1(+Directory).

This predicate is defined in the configuration file.  The argument |Directory|
is a string describing the directory which contains the Setheo executables.

\PL*/
:- define_setheo(Home),
   (define_option 'setheo:home' = Home).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option |setheo:home| contains the directory of the Setheo executables. It
is initialized from the default value specified in the configuration file
(which in turn might be generated by a Makefile).

\PL*/
:- define_option 'setheo:flags'		= [cons,opt,verbose,dr].
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option |setheo:flags|  contains a list  of options for the setheo programs
|inwasm|, |wasm|, and |sam|.  It is identical  to the command line switches of
those programs  without the leading   |-|.  See the Setheo  documentation  for
details.

\PL*/
:- define_option 'setheo:tmpdirs'	= [indir,".","/tmp","~"].
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option |setheo:tmpdirs| contains a list of directories which are
considered for generating intermediate files. |indir| denotes the directory
containing the input file.

\PL*/
:- define_option 'setheo:remove_tmp_files' = on.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option |setheo:remove_tmp_files| controlls wether the intermediate files
generated for or by Setheo are removed afterwards.

\PL*/
:- make_local_array('Setheo:prefix').
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
\bigskip

This module exports one predicate:

\Predicate setheo/0().

This predicate saves the current matrix in a formar suitable for Setheo. The
three phases of Setheo (inwasm, wasm, sam) are called in turn as long as no
error occurs. Finally the output of Setheo is analyzed and translated into a
format suitable for \ProTop.

\PL*/
setheo :-
	setheo_determine_files(InFile,InBase,OutFile,TreeFile),
	open(InFile,write,Stream),
	setheo_save_matrix(Stream),
	close(Stream),
	is_option('setheo:home',Setheo),
	is_option('setheo:flags',Flags),
	setheo_make_command_line(Flags,inwasm,IMWASM_FLAGS),
	( execute([Setheo,"/inwasm ",IMWASM_FLAGS,InBase,">",OutFile]) -> 
	    setheo_make_command_line(Flags,wasm,WASM_FLAGS),
	    ( execute([Setheo,"/wasm ",WASM_FLAGS,InBase,">>",OutFile]) ->
		setheo_make_command_line(Flags,sam,SAM_FLAGS),
		( execute([Setheo,"/sam ",SAM_FLAGS,InBase,">>",OutFile]) ->
		    true ; true ),
		( exists(TreeFile) ->
		    open(TreeFile,read,Stream2),
		    is_option(log_file,LOG),
		    analyze_setheo(Stream2,LOG),
		    close(Stream2)
		;   true
		),
		( is_option('setheo:remove_tmp_files') ->
		    delete_file(InFile),
		    delete_file(OutFile),
		    delete_file(TreeFile),
		    delete_file([InBase,".hex"]),
		    delete_file([InBase,".s"])
		;   true
		)
	
	    ;	err("*** Setheo Error. wasm failed.")
	    )
	;   err("*** Setheo Error. inwasm failed.")
	),
	!.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate setheo_determine_files/2(-InFile, -OutFile).

Setheo requires two files to be specified. The file |InFile| contains the flags
and the problem. By convention it has the extension {\sf .lop}. The file
|OutFile| is used to hold the results. It has the extension {\sf .log}.

This predicate tries to figure out sensible values for those files.

\PL*/
setheo_determine_files(InFile,InBase,OutFile,TreeFile) :-
	is_option(input_path,Path),
	is_option(input_extensions,Extensions),
	( is_option(input_file,Input_File),
	  Input_File \== [],
	  find_file(Input_File,['.'|Path],[''|Extensions],F) ->
	    pathname(F,In_Dir,In_Name),
	    ( string_length(In_Dir,0) ->
		InDirectory = "./"
	    ;	InDirectory = In_Dir
	    )
	;   InDirectory = "./"
	),
	    
	is_option('setheo:tmpdirs',DirList),
	( member(Directory,DirList) ->
	    ( Directory = indir ->
		Dir = InDirectory
	    ;	Dir = Directory
	    ),
	    get_file_info(Dir,readable,on),
	    get_file_info(Dir,writable,on),
	    get_file_info(Dir,executable,on)
	;   Dir = "/tmp/"
	),
	concat_string([Dir,In_Name],InBase),
	concat_string([InBase,".lop" ],InFile),
	concat_string([InBase,".slog"],OutFile),
	concat_string([InBase,".tree"],TreeFile).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate setheo_save_matrix/1(+Stream).

This predicate writes the current matrix onto the stream |Stream|. This is
done in a format suitable for Setheo, i.e. in the lop format.

\PL*/
setheo_save_matrix(Stream) :-
	printf(Stream,"\n",[]),
	(   'Clause'(Idx,LitList),
	    printf(Stream,"\n%%	 Clause %w\n",[Idx]),

	    setval('Setheo:prefix',""),
	    (	member(literal(++L,_),LitList),
		getval('Setheo:prefix',Prefix),
		setval('Setheo:prefix',";\n\t"),
		printf(Stream,"%w%w",[Prefix,L]),
		fail
	    ;	
		setval('Setheo:prefix',""),
		printf(Stream,"\t<-\n\t",[]),
		member(literal(--L,_),LitList),
		getval('Setheo:prefix',Prefix),
		setval('Setheo:prefix',",\n\t"),
		printf(Stream,"%w%w",[Prefix,L]),
		fail
	    ;	
		printf(Stream,".\n\n",[])
	    ),
	    fail
	;   true
	),
	printf(Stream,"\n\n",[]).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate analyze_setheo/2().

This predicate is used to analyze the output of Setheo and put the appropriate
informations into the log file. Additionally things are displayed on the
screen. The relevant information is read from the input stream |Stream| which
should be opened to read the |.tree| file.

\PL*/
analyze_setheo(Stream,Report) :-
	read(Stream,Proofs),
	( Proofs = [[~query__,[_,ext(A,_)],[_|SetheoProof]]|_] ->
	    analyze_setheo_proof(SetheoProof,Tree),
	    Proof = proof(A,Tree),
	    save_proof(Report,Proof),
	    (show_proof(output,Proof)->true;true)
	;   true
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate analyze_setheo_proof/2(+Setheo, ?ProTop).

\PL*/
analyze_setheo_proof([],[]).
analyze_setheo_proof([Step],[TreeStep]) :-
	!,
	analyze_setheo_proof_step(Step,TreeStep).
analyze_setheo_proof([Step|Rest],[TreeStep|Steps]) :-
	analyze_setheo_proof_step(Step,TreeStep),
	analyze_setheo_proof(Rest,Steps).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate analyze_setheo_proof_step/2(+Setheo, ?ProTop).

\PL*/
analyze_setheo_proof_step([Literal,[No,Rule]],Tree) :-
	convert_literal(Literal,Lit),
	Rule =.. List,
	append(List,[Lit,No],Node),
	Tree =.. Node.
analyze_setheo_proof_step([Literal,[No,Rule],[_|Sub]],Tree) :-
	convert_literal(Literal,Lit),
	analyze_setheo_proof(Sub,SUB),
	( Rule = ext(A,B) ->
	    Tree = ext(A-B,Lit,No,SUB)
	;
	    Rule =.. List,
	    append(List,[Lit,No,SUB],Node),
	    Tree =.. Node
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate convert_literal/2(+Setheo, ?ProTop).

A negated literal in Setheo is marked with a leading |~|. This is converted to
the \ProTop{} notation |--|. Positive literals are left unchanged.

\PL*/
convert_literal(~L,--L) :- !.
convert_literal(L,L)	:- !.
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate setheo_make_command_line/3(+List, +Type, ?String).

\PL*/
setheo_make_command_line([],_,"").
setheo_make_command_line([H|T],Type,Args) :-
	setheo_make_command_line(T,Type,TArgs),
	( setheo_flag(H,Type) ->
	    ( (atom(H); string(H)) ->
		concat_string(["-",H," ",TArgs],Args)
	    ; H = (F=N),
	      atom(F),
	      number(N) ->
	        concat_string(["-",F," ",N," ",TArgs],Args)
	    ;   err("*** Type error."),
	        Args = TArgs
	    )
	;   Args = TArgs
	).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\Predicate setheo_flag/2(?Flag, ?Program).

\PL*/
setheo_flag(purity,		inwasm).
setheo_flag(nopurity,		inwasm).
setheo_flag(nofan,		inwasm).
setheo_flag(reduct,		inwasm).
setheo_flag(noreduct,		inwasm).
setheo_flag(nosgreord,		inwasm).
setheo_flag(noclreord,		inwasm).
setheo_flag(notree,		inwasm).
setheo_flag(randreord,		inwasm).
setheo_flag(eqpred,		inwasm).
setheo_flag(all,		inwasm).
setheo_flag(reg,		inwasm).
setheo_flag(subs,		inwasm).
setheo_flag(taut,		inwasm).
setheo_flag(cons,		inwasm).
setheo_flag(foldup,		inwasm).
setheo_flag(foldupx,		inwasm).
setheo_flag(folddown,		inwasm).
setheo_flag(folddownx,		inwasm).
setheo_flag(partialtree,	inwasm).
setheo_flag(nopartialtree,	inwasm).
setheo_flag(verbose = _,	inwasm).
setheo_flag(verbose,		inwasm).

setheo_flag(verbose,		wasm).
setheo_flag(opt,		wasm).

setheo_flag(d = _,		sam).
setheo_flag(d,			sam).
setheo_flag(i = _,		sam).
setheo_flag(i,			sam).
setheo_flag(dr = _,		sam).
setheo_flag(dr,			sam).
setheo_flag(ir = _,		sam).
setheo_flag(ir,			sam).
setheo_flag(loci,		sam).
setheo_flag(locir,		sam).
setheo_flag(anl,		sam).
setheo_flag(reg,		sam).
setheo_flag(st,			sam).
setheo_flag(cons,		sam).
setheo_flag(code = _,		sam).
setheo_flag(stack = _,		sam).
setheo_flag(cstack = _,		sam).
setheo_flag(heap = _,		sam).
setheo_flag(trail = _,		sam).
setheo_flag(symbtab = _,	sam).
setheo_flag(seed = _,		sam).
setheo_flag(v = _,		sam).
setheo_flag(v,			sam).
setheo_flag(verbose = _,	sam).
setheo_flag(verbose,		sam).
/*PL%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
\EndProlog */
